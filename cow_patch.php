<?php
/*
 *  cow_patch.php
 *
 * Author: Michel Jansens
 * Date April 08, 2013.
 * Version: 0.1
 * Dependencies: php5.x
 *
 */

/*
 * This programs takes a diff stream (generated by zvol_snap_diff.php) as standard input and apply binary mods to the device given in parameter
 * diff stream format:
 * <blocksize in hexadecimal>\n
 * '+'|'-'|'M' <offset in hexadecimal>\n
 * <block data>
 * ....
 * 
 * example:
 * host1> php zvol_snap_diff.php -d zones/imageuuid@dataset zones/vmuuid-disk0@migration | ssh host2 "php cow_patch.php /dev/zvol/dsk/vmuuid-disk0"
 */
 if($argc!=2){
     fprintf(stderr,"syntax: %s <file>\nReads a block diff from standard input and (re)write created/modified blocks.\n",$argv[0]);
     exit(1);
 }
//open device for read and write
$file_fp=fopen($argv[1],"r+");
if(!$file_fp){
  fprintf(STDERR,"could not open %s\n",$argv[1]);
  exit(2);
}
  
//get blocksize
$readbuf=fgets(STDIN);
sscanf($readbuf, "%x", $blocksize);	
fprintf(STDERR,"blocksize: %010d\n",$blocksize);

//read next mod line (type offset)
$line=fgets(STDIN);
	while( !feof(STDIN)){
		sscanf($line, "%c %x",$mod,$offset);
		//now read the block's data
                if($mod=='+' || $mod=='M'){
                $buff_len=0;
                $buff_idx=0;
                $block_read_size=0;
                //PHP does non blocking read on stdin it seems so it doesn't alway return expected number of bytes
                while($block_read_size != $blocksize && !feof(STDIN)){
                  $block_buffer[$buff_idx]=fread(STDIN,$blocksize-$block_read_size);
                  $block_read_size+=strlen($block_buffer[$buff_idx]);
                  $buff_idx+=1;
                }
		//?complete blocks
		if($block_read_size!=$blocksize){
		  fprintf(STDERR,"could not read a complete block from stdin only got %d\n",$block_read_size);
		  exit(3);
		}
		//position cursor to the righ block
		fseek($file_fp, $offset, SEEK_SET );	
		//do the writing (on a new block as per Copy on Write)
                $write_len=0;
                for($i=0;$i<$buff_idx;$i++) $write_len+=fwrite($file_fp, $block_buffer[$i], $blocksize);
		//fprintf(STDERR,"Would write block hex %x\n",$offset);
               
                if($write_len!=$blocksize){
		  fprintf(STDERR,"error writing at offset %d\n",$offset);
		  exit(4);
		  }
                 
                 
                 }
                 else{
                  if($mod=='-'){
                    //block suppression should trim or write zeros
                     fprintf(STDERR,"block suppression should trim or write zeros at block hex %x\n",$offset); 
                  }   
                 }
		//read next mod line
		$line=fgets(STDIN);
	}//end while
       
?>
